<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"flatly.js.html":{"id":"flatly.js.html","title":"Source: flatly.js","body":" flatly Classes flatlyio Source: flatly.js /** * @fileOverview * @author Liam Whan * @memberOf core * */ ; (function () { &quot;use strict&quot;; const io = require('./io'); const path = require('path'); const _ = require('lodash'); /** * flatly class contains the entire flatly api * @func flatly * @classdesc flatly is a simple flat file JSON db system. * IMPORTANT: flatly is under active development and is not considered production ready * @class * @constructor * @returns {flatly} */ function flatly() { if (new.target === undefined) { throw &quot;You must instantiate flatly. e.g. const Flatly = require('flatly');\\r\\nvar flatly = new Flatly();&quot; } //region Private members /** * @member _tables Tables collection * @type {Object} * @private */ let _tables = [], /** * @member _files Array of table file names * @type {Array} * @private */ _files, /** * @member _baseDir The base directory where the table files are located. * @type {string} * @private */ _baseDir = &quot;&quot;; /** * Get the flatly metadata from an object * @func flatly~getMeta * @param obj The object to check * @returns {Object|boolean} * @private */ let _getMeta = (obj) =&gt; { if (!_.has(obj, '$$flatly')) { return false; } else { return obj['$$flatly']; } }; /** * Returns the a new Id for a table * @func flatly~nextId * @param tblName {Object} The table to query * @private * @returns {number} */ let _nextId = (table) =&gt; { let maxId = _.max(_.map(table, 'id')); return maxId + 1; }; /** * Removes flatly metadata before saving to disk * @function flatly~_removeMeta * @param data * @returns {*} * @private */ let _removeMeta = (data) =&gt; { var clone = _.cloneDeep(data); if (_.has(clone, '$$flatly')) { delete clone['$$flatly']; } _.each(clone, (row) =&gt; { if (_.has(row, '$$flatly')) { delete row['$$flatly']; } }); return clone; }; /** * Adds flatly metadata to db object * @param data {Object|Array} the data to tag * @param [tblName] {String} a string identifier for what * @returns {*} * @private */ let _addMeta = () =&gt; { let clone = _.cloneDeep(_tables); if (!_.has(clone, '$$flatly')) { _.forIn(clone, (tbl, tblName) =&gt; { let meta = { $$flatly: { table: tblName } }; _.forIn(tbl, (row) =&gt; { _.assign(row, meta); }); }); } return clone; }; /** * @function flatly~_parseCriteria * @desc Helper method to parse the search criteria object * @private * @param criteria {Object} The criteria object to parse * @param criteria.from {String} Table name * @param criteria.where {Object} An object defining the search criteria * @param criteria.where.column {String} the Column name to search * @param criteria.where.equals {String} the search term. * @returns {Object} The search result object is of form {&quot;columnName&quot;: searchTerm} which is used by the find methods */ function _parseCriteria(criteria) { if (!_.has(criteria, 'from') || !_.has(criteria, 'where') || !_.has(criteria, 'where.column') || !_.has(criteria, 'where.equals') ) { throw new Error('You must include both &quot;where&quot; and &quot;from&quot; criteria to use findOne()'); } let search = {}; search[criteria.where.column.toLowerCase()] = criteria.where.equals; return search; } //endregion // region Public /** * The name of the database currently in use * @member {String} */ this.name = undefined; /** * Returns currently selected database name and table names * * @function flatly#dbInfo * @returns {{name: String, tables: Array, count: number}} An object with the database name, table names and table count */ this.dbInfo = () =&gt; { return { name: this.name, tables: this.getSchema(), count: this.getSchema().length } }; /** * Returns the schema of the currently selected DB * * @function flatly#getSchema * @example console.log(flatly.getSchema()); * // -&gt; ['table1', 'table2', 'table3'] * @returns {string[]} */ this.getSchema = () =&gt; _.keys(_tables); /** * Returns a deep clone of the tables array * * @memberOf flatly * @function flatly#tables * @returns {Array} */ this.tables = () =&gt; _tables; /** * Returns an object representing the table requested. Use {@link flatly#findOne} or {@link flatly#findAll} for querying table contents * * @function flatly#getTable * @param tblName {String} The name of the table to be returned * @returns {Object} An object representing the requested table */ this.getTable = function (tblName) { tblName = tblName.toLowerCase(); return _.cloneDeep(_tables[tblName]); }; /** * Returns a row from the specified table * * @function flatly#findOne * @param {Object} criteria An options object with the search details * @param {String} criteria.from The name of the table to search * @param {Object} criteria.where An object containing the column and value criterion * @params {String} criteria.where.column The name of the column to search * @params {number|String} criteria.where.equals The value to search the column for * @returns {?Object} A row object */ this.findOne = (criteria) =&gt; { let tblName = criteria.from; let search = _parseCriteria(criteria); let tblTarget = this.getTable(tblName.toLowerCase()); let result = _.find(tblTarget, search); return result || null; }; /** * Returns all rows that match the criteria object * @function flatly#findAll * @param {Object} criteria An options object with the search details * @param {String} criteria.from The name of the table to search * @param {Object} criteria.where An object containing the column and value criterion * @params {String} criteria.where.column The name of the column to search * @params {number|String} criteria.where.equals The value to search the column for * @returns {*} */ this.findAll = (criteria) =&gt; { if (!_.has(criteria, 'from') || !_.has(criteria, 'where') || !_.has(criteria, 'where.column') || !_.has(criteria, 'where.equals') ) { throw new Error('You must include both &quot;where&quot; and &quot;from&quot; criteria to use findAll()'); } let search = {}; search[criteria.where.column] = criteria.where.equals; let result = _.filter(this.getTable(criteria.from), search); return (result) ? [result] : null; }; /** * Loads a database from the specified filepath * * @function flatly#use * @param options {Object} * @param options.name {String} Specify a name for the database * @param options.src {String} A path to the required data * @returns {flatly} */ this.use = function (options) { this.name = options.name.toLowerCase(); _baseDir = path.resolve(global.parent, options.src); _files = io.getAll({src: _baseDir}); let tablesClean = io.parse(options.name, _files); _tables = tablesClean; /* Add table and row metadata */ _addMeta(); return this; }; /** * Refresh table from disk * @func flatly#refreshTable * @param tblName {string} Table name to refresh * @returns {object} Table */ this.refreshTable = function (tblName) { var filename = tblName.toLowerCase() + &quot;.json&quot;; var filePath = path.join(_baseDir, filename); var tbl = io.getOne(filePath); _tables[tblName] = tbl; _addMeta(); return _tables[tblName]; }; /** * Save table data to disk. Remove flatly metadata before saving. * * @func flatly#save * @param options {Object} * @param options.table {string} The table to save * @param [options.overwrite=false] Overwrite the existing table? * @param [options.async=false] {boolean} Sync/Async Execution. Defaults to Sync * @param [callback] {function} The callback to execute if we're working asynchronously * @returns {flatly} */ this.save = function (options, callback) { if (!_.has(options, 'table')) { throw new Error('You must pass a &quot;table&quot; parameter to use save()'); } _.defaults(options, {overwrite: false}, {async: false}); let target = _removeMeta(this.getTable(options.table)); let filename = options.table; let tblFile = path.normalize(path.format({ dir: _baseDir, base: filename + &quot;.json&quot;, ext: &quot;.json&quot;, name: options.table })); if (_.has(options, 'async') &amp;&amp; options.async) { if (_.isUndefined(callback)) { throw Error(&quot;save() is set to async and no callback was supplied.&quot;); } else { io.put(target, tblFile, callback, options.overwrite); return this; } } else { io.put(target, tblFile, options.overwrite); this.refreshTable(options.table); return this; } }; /** * Check if a record (row) exists within a given table * @param {string} tblName The name of the table to check * @param {string} column The column to search * @param {*} value The value to search for * @func flatly#checkExists * @example if(flatly.checkExists('table1', 'id', 1)) { //do something } * @return {boolean} Returns {true} if the value is found {false} otherwise */ this.checkExists = (tblName, column, value) =&gt; { var bool = this.findOne({from: tblName, where: {column: column, equals: value}}); if (_.isNull(bool)) { return false; } else { return true; } }; /** * Insert a row into a table * @func flatly#insert * @param row {object} Row object to insert * @param tblName {string} Name of the table to insert into * @returns {flatly} */ this.insert = (row, tblName) =&gt; { let table = this.getTable(tblName); if (!_.isNull(table)) { let newId = table.length === 0 ? 1 : _nextId(table); row.id = newId; _tables[tblName].push(row); addMeta(); return row; } else { throw Error('Table not found: ', tblName); } }; /** * Update an existing table row * @func flatly#update * @param rowData {Object} An object representing a row of the target table * @param matchBy {String} The key to use to match rowData to an existing row in the table * @param tblName {String} The target table name * @example flatly.update({ * id: 6, * name: Michael Flatly * }, 'id', 'customers'); * @returns {flatly} */ this.update = (rowData, matchBy, tblName) =&gt; { if (_.has(rowData, '$$flatly')) { tblName = rowData.$$flatly.table; } else { if (_.isUndefined(tblName)) { throw new Error(&quot;You must pass a flatly object or the name of the table to insert the data into&quot;); } } if (!_.has(rowData, matchBy)) { throw new Error(&quot;The key: &quot; + matchBy + &quot; does not exist.&quot;); } var where = { column: matchBy, equals: rowData[matchBy] }; var old = this.findOne({from: tblName, where: where}); if (old) { let index = _.findIndex(_tables[tblName], old); if (index !== -1) { _tables[tblName].splice(index, 1, rowData); } else { console.warn(&quot;Could not find the specified Row in table &quot; + tblName); } } else { console.warn(&quot;No object found&quot;, matchBy); } return this; }; //endregion }//end flatly() module.exports = flatly; })(); × Search results Close "},"io.js.html":{"id":"io.js.html","title":"Source: io.js","body":" flatly Classes flatlyio Source: io.js /** * @memberOf core */ (function () { const fs = require('graceful-fs'); const glob = require('glob'); const jph = require('json-parse-helpfulerror'); const parse = jph.parse; const _ = require('lodash'); const path = require('path'); /** * @namespace io * @classdesc Main flatly class used to load db and query data * @constructor * @desc I/O Operations for the flatly library * @class */ function io() { &quot;use strict&quot;; /** * @func io#getAll * @desc Takes a glob pattern and returns an array of table files * @param options {Object} * @param options.src {String} Glob pattern of target files * @param {string} [options.format=JSON] A string switch that tells flatly what format the source files are in * @returns {Array} * @example var files = io.getAll('../data/*.json') */ this.getAll = function (options) { _.defaults(options, {format: 'JSON'}); var pattern = &quot;&quot;; if(options.format !== 'JSON') { //TODO add support for other formats } else { pattern = path.join(options.src, '/**/*.json'); } try { var files = glob.sync(pattern); } catch (e) { if(e.message == 'must provide pattern') { console.error('Theres something wrong with the supplied glob: ', pattern); } } if(files.length == 0) { throw new Error(&quot;No files found at: &quot; + pattern); } return files; }; this.getOne = function(filePath) { return parse(fs.readFileSync(filePath)); }; /** * @desc Parse JSON files into JS objects * @param dbName {String} * @param {String|Array} tables | A string containing the filepaths of the tables * @returns {Object} */ this.parse = function (dbName, tables) { if (!_.isArray(tables)) { tables = [tables]; } var results = {}; tables.forEach(function (item) { var tblName = path.basename(item, path.extname(item)).toLowerCase(); var tblData = parse(fs.readFileSync(item)); results[tblName] = tblData; }); return results; }; /** * Write data to file * @param {Object} data * @param {string} destination * @param {boolean} overwrite * @param {function} callback * @param {boolean} [overwrite=false] Overwrite the existing table file? */ this.put = (data, destination, overwrite, callback) =&gt; { let ts = &quot;-&quot; + new Date().getTime().toString(); let dir = path.dirname(destination); var stringified = JSON.stringify(data, null, 2); if(overwrite) { let back = path.join(dir, path.basename(destination, path.extname(destination)) + ts + '.bak'); this.backup(destination, back); } else { let file = path.basename(destination, path.extname(destination)) + ts + '.json'; destination = path.join(dir, file); } if(!_.isUndefined(callback)) { fs.writeFile(destination, stringified,{}, callback); } else { fs.writeFileSync(destination, stringified); } }; /** * Write data to file synchronously * @deprecated Will be removed in version 0.1.6 * @param {Object} data * @param {string} destination * @param {boolean} overwrite * @param {function} callback * @param {boolean} [overwrite=false] Overwrite the existing table file? */ this.putSync = (data, destination, overwrite, callback) =&gt; { _.defaults(overwrite, false); let ts = &quot;-&quot; + new Date().getTime().toString(); let dir = path.dirname(destination); var stringified = JSON.stringify(data, null, 2); if(overwrite) { let back = path.join(dir, path.basename(destination, path.extname(destination)) + ts + '.bak'); this.backup(destination, back); } else { let file = path.basename(destination, path.extname(destination)) + ts + '.json'; destination = path.join(dir, file); } if(!_.isUndefined(callback)) { fs.writeFile(destination, stringified, callback); } else { fs.writeFileSync(destination, stringified); } } /** * Create a backup of a file * @param source * @param destination */ this.backup = (source, destination) =&gt; { console.log('backing up to: ', destination); var oldData = fs.readFileSync(source); fs.writeFileSync(destination, oldData); //fs.createReadStream(source).pipe(fs.createWriteStream(destination)); } } module.exports = new io(); })(); × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" flatly Classes flatlyio Classes Classes flatly io × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" flatly Classes flatlyio flatly 0.1.14 Index flatly.js Author: Liam Whan Source: flatly.js, line 1 × Search results Close "},"flatly.html":{"id":"flatly.html","title":"Class: flatly","body":" flatly Classes flatlyio Class: flatly flatly flatly is a simple flat file JSON db system.IMPORTANT: flatly is under active development and is not considered production ready new flatly() flatly class contains the entire flatly api Source: flatly.js, line 16 Returns: Type flatly Methods checkExists(tblName, column, value) Check if a record (row) exists within a given table Parameters: Name Type Description tblName string The name of the table to check column string The column to search value * The value to search for Source: flatly.js, line 351 Returns: Returns {true} if the value is found {false} otherwise Type boolean Example if(flatly.checkExists('table1', 'id', 1)) { //do something } dbInfo() Returns currently selected database name and table names Source: flatly.js, line 169 Returns: An object with the database name, table names and table count Type Object findAll(criteria) Returns all rows that match the criteria object Parameters: Name Type Description criteria Object An options object with the search details Properties Name Type Description from String The name of the table to search where Object An object containing the column and value criterion Source: flatly.js, line 238 Returns: Type * findOne(criteria) Returns a row from the specified table Parameters: Name Type Description criteria Object An options object with the search details Properties Name Type Description from String The name of the table to search where Object An object containing the column and value criterion Source: flatly.js, line 216 Returns: A row object Type Object getSchema() Returns the schema of the currently selected DB Source: flatly.js, line 184 Returns: Type Array.&lt;string&gt; Example console.log(flatly.getSchema()); // -&gt; ['table1', 'table2', 'table3'] getTable(tblName) Returns an object representing the table requested. Use flatly#findOne or flatly#findAll for querying table contents Parameters: Name Type Description tblName String The name of the table to be returned Source: flatly.js, line 204 Returns: An object representing the requested table Type Object insert(row, tblName) Insert a row into a table Parameters: Name Type Description row object Row object to insert tblName string Name of the table to insert into Source: flatly.js, line 370 Returns: Type flatly refreshTable(tblName) Refresh table from disk Parameters: Name Type Description tblName string Table name to refresh Source: flatly.js, line 288 Returns: Table Type object save(options, callback) Save table data to disk. Remove flatly metadata before saving. Parameters: Name Type Argument Description options Object Properties Name Type Argument Default Description table string The table to save overwrite &lt;optional&gt; false Overwrite the existing table? async boolean &lt;optional&gt; false Sync/Async Execution. Defaults to Sync callback function &lt;optional&gt; The callback to execute if we're working asynchronously Source: flatly.js, line 308 Returns: Type flatly tables() Returns a deep clone of the tables array Source: flatly.js, line 195 Returns: Type Array update(rowData, matchBy, tblName) Update an existing table row Parameters: Name Type Description rowData Object An object representing a row of the target table matchBy String The key to use to match rowData to an existing row in the table tblName String The target table name Source: flatly.js, line 398 Returns: Type flatly Example flatly.update({ id: 6, name: Michael Flatly }, 'id', 'customers'); use(options) Loads a database from the specified filepath Parameters: Name Type Description options Object Properties Name Type Description name String Specify a name for the database src String A path to the required data Source: flatly.js, line 263 Returns: Type flatly × Search results Close "},"io.html":{"id":"io.html","title":"Class: io","body":" flatly Classes flatlyio Class: io io Main flatly class used to load db and query data new io() I/O Operations for the flatly library Source: io.js, line 14 Methods getAll(options) Takes a glob pattern and returns an array of table files Parameters: Name Type Description options Object Properties Name Type Argument Default Description src String Glob pattern of target files format string &lt;optional&gt; JSON A string switch that tells flatly what format the source files are in Source: io.js, line 24 Returns: Type Array Example var files = io.getAll('../data/*.json') × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
